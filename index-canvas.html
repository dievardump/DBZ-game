<!DOCTYPE html>
<head>
    <script src="./socket.io/socket.io.js"></script>
    <script src="./assets/js/lib/mootools/mootools-core-1.4.2.js"></script>
    <script>
        var socket = io.connect('http://localhost:8080');
            socket.on('news', function (data) {
            console.log(data);
            socket.emit('my other event', { my: 'data' });
        });

        window.addEvent('domready',
            function()
            {
                var stage = $('stage');
                
                // configuration
                var config = {};
                
                // keys configuration - could be saved for each profil if accounts come
                config.key = { 
                    'up' : 'up', 
                    'right' : 'right', 
                    'left' : 'left', 
                    'punch' : 'a', 
                    'kick' : 'z', 
                    'highkick' : 'e', 
                    'fireball' : 'q', 
                    'block' : 's'
                };
                
                // sprites configuration
                config.sprites = {
                    wait : {
                      x : 82,
                      y : 0
                    },
                    forward : {
                        x : 164,
                        y : 0
                    },
                    backward : {
                        x : 246,
                        y : 0
                    },
                    up : {
                        x : 328,
                        y : 0
                    },
                    punch : {
                        x : 0,
                        y : 102
                    },
                    kick : {
                        x : 82,
                        y : 102
                    },
                    highkick : {
                        x : 164,
                        y : 102
                    },
                    punchvert : {
                        x : 246,
                        y : 102
                    },
                    highkickvert : {
                        x : 328,
                        y : 102
                    },
                    kickvert : {
                        x : 328,
                        y : 102
                    },
                    fireball : {
                        x : 246,
                        y : 306,
                        w : 32,
                        h : 24
                    },
                    block : {
                        x : 328,
                        y : 204
                    },
                    special : {
                        fireball : {
                            blue : {
                                x : 0,
                                y : 258
                            },
                            purple : {
                                x : 32,
                                y : 258
                            }
                        }
                    }
                        
                };
                
                // fps
                config.fps = 1000/30;
                
                // power used by actions
                config.power = {
                    fireball : 25
                };
                
                // times
                config.times = {
                    action : 200,
                    jump : 600,
                    moveaction : 400,
                    fireballaction : 100,
                    fireballmovement : 1000
                };
                
                // if we use canvas to render or not
                config.canvas = true;
                
                // images used 
                config.images = {
                    data : {
                        special : {
                            src : 'assets/img/sprites/special.png',
                            width : 328,
                            height : 282
                        },
                        goku : {
                            src : 'assets/img/sprites/characters/goku.png',
                            width : 410,
                            height : 408
                        },
                        a18 : {
                            src : 'assets/img/sprites/characters/a18.png',
                            width : 410,
                            height : 408
                        }
                    },
                    element : {}
                };
                
                //config sizes
                config.size = {
                    character : {
                        x : 82,
                        y : 102
                    }
                }
                
                // blocking action
                config.block = {
                    block : true
                }
                
                for(var key in config.images.data)
                    config.images.element[key] = new Element('img', config.images.data[key]);
                
                var Character = function() {    };
                Character.prototype.getFireBall = function()
                {
                    var oFireBall, 
                        currentPos = this.getRealPosition(), 
                        iLeft = currentPos.x,
                        sPos = this.pos.stage;
                                
                    if ( sPos == 'left' )
                        iLeft += this.sizes.element.x;
                    else
                        iLeft -= config.sprites.fireball.w;
                    
                    if ( config.canvas )
                    {
                        oFireBall = new Element('canvas',
                            {
                                width : config.sprites.fireball.w,
                                height : config.sprites.fireball.h,
                                styles : {
                                    position : 'absolute',
                                    'z-index' : 5,
                                    left : iLeft,
                                    bottom : currentPos.y + this.sizes.element.y/3 + this.positions.layer.y
                                }
                            }
                        );
                        var oFireBallContext = oFireBall.getContext('2d');
                        if ( sPos == 'right')
                        {
                            // return canvas
                            oFireBallContext.translate(oFireBall.width, 0);
                            oFireBallContext.scale(-1, 1);
                        }

                        oFireBallContext.drawImage(
                            config.images.element.special, 
                            config.sprites.special.fireball[this.options.color].x, 
                            config.sprites.special.fireball[this.options.color].y, 
                            config.images.data.special.width, 
                            config.images.data.special.height, 
                            0, 0, 
                            config.images.data.special.width, 
                            config.images.data.special.height
                        );
                    }
                    else
                    {

                        oFireBall = new Element('div', {
                            styles : {
                                width : config.sprites.fireball.w,
                                height : config.sprites.fireball.h,
                                position : 'absolute',
                                'z-index' : 5,
                                left : iLeft,
                                bottom : currentPos.y + this.sizes.element.y/3 + this.positions.layer.y,
                                'background-image' : 'url('+config.images.data.special.src+')',
                                'background-position' : '-'+config.sprites.special.fireball[this.options.color].x + 'px -'+config.sprites.special.fireball[this.options.color].y+'px'
                            }
                        });

                        if ( sPos == 'right')
                            oFireBall.addClass('flip');
                    }
                    return oFireBall;
                };
            /**
             * DrawManager class
             * Used to manage the drawing iterations
             **/
            var DrawManager = new Class({
                initialize : function(canvas, ctx) {

                    // shapes to draw
                    this.shapes = [];

                    this.shapeslength = 0;

                    this.canvas = canvas;
                    this.ctx = ctx;
                },


                start : function() {
                    this.iterate();
                },


                /*
                * Function called at every iteration
                */
                iterate : function() {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                    //Debug fps
                    //var tBegin = +(new Date());
                    var shapes = [];
                    for(var i=0, l =  this.shapeslength; i < l; i++) {
                        shapes = this.shapes[i];
                        if (!shapes) {continue;}

                        for(var j = 0, length = shapes.length; j < length; j++) {
                            shapes[j].iterate();
                        }
                    }
                    
                    //Debug fps
                    //console.log((1000/(+(new Date()) - tBegin)) + " fps");

                    var that = this;
                    window.setTimeout(function() { that.iterate(); }, 1000/30);
                },

                /*
                * Function to add a shape to draw
                * @param shape (Object) - Shape to add
                * @param deep (integer) - deep of the shape (used when drawing)
                */
                add : function(shape, deep) {
                    if (!deep) { 
                        deep = 1;
                    }
                    
                    if (!this.shapes[deep]) {
                        this.shapes[deep] = [];
                    }

                    if (!~this.shapes[deep].indexOf(shape)) {
                        this.shapes[deep].push(shape);
                    }

                    this.shapeslength = this.shapes.length;
                    return this;

                },

                /*
                * Function to remove a shape to draw
                * @param shape (Object) - Shape to add
                * @param deep (integer) - deep of the shape (used when drawing)
                */
                remove : function(shape, deep) {
                    if (!deep) { 
                        deep = 1;
                    }
                    if (!this.shapes[deep]) {
                        return this;
                    }

                    var index = this.shapes[deep].indexOf(shape);
                    if (~index) {
                        this.shapes[deep].slice(index, 1);
                    }

                    this.shapeslength = this.shapes.length;
                    return this;
                }

            });
            
            
            /**
             * Vector representation
             **/
            var Vector = (function() {
                function norm(value) {
                    return value > 0 ? 1 : value < 0 ? -1 : 0;
                };

                return new Class({
                    initialize : function(x, y) {
                        this.x = x;
                        this.y = y;
                    },

                    add: function(other) {
                        return new Vector(this.x1 + other.x1, this.x2 + other.x2);
                    },
                    scale: function(by) {
                        return new Vector(this.x1 * by, this.x2 * by);
                    },
                    normalize: function() {
                        return new Vector(norm(this.x1), norm(this.x2));
                    }
                });
            })();
    
            /**
             * DBZ Game class
             * Manage the characters and the drawing
             */
            var DBZ = new Class({
                Implements : [Options],
                
                currentPlayer : null,
                characters : [],
                
                initialize : function(inject, options) {
                    
                    this.drawer = inject.drawer;
                    this.stage = inject.stage;
                    this.players = inject.players;
                    this.currentPlayer = inject.currentPlayer;
                    
                    this.setOptions(options);
                    
                    
                    this.createCharacters();
                    
                    this.drawer.start();
                },
                
                createCharacters : function() {
                    // create the characters according to the players specifications
                    var i = 0,
                        len = this.players.length,
                        oCharacter = null,
                        oPlayer = null,
                        inject = {}, 
                        options = {},
                        iStageSize = this.stage.width,
                        iQuart = iStageSize/4;
                        
                    while(i < len) {
                        
                        oPlayer = this.players[i];
                        
                        
                        inject = {
                            manager : this.drawer
                        };
                        
                        options = {
                            img : oPlayer.options.img,
                            move : {
                                max : {
                                    x : iStageSize - config.size.character.x
                                }
                            }
                        };

                        if ( i == 1 ) {
                            options.move.from = {
                                x :  3*iQuart - config.size.character.x / 2
                            };
                        } else {
                            options.move.from = {
                                x :  iQuart - config.size.character.x / 2
                            };
                        }
                        
                        options.move.from.y = this.stage.height - config.size.character.y - 25;
                        options.move.to = { y : options.move.from.y - 140 };
                        
                        // create the character
                        oCharacter = new DBZCharacter(inject, options);
                        if ( i == 1 ) {
                            oCharacter.changePosition();
                        }
                        
                        // add the character to the current character collection
                        this.characters.push(oCharacter);
                        this.drawer.add(oCharacter);
                        
                        // if it's the current player character, add listeners
                        if (oPlayer.id === this.currentPlayer.id) {
                            this.listenTo(oCharacter);
                        }
                        
                        i++;
                    }
                        
                },
                
                /**
                 * Add listeners to a character
                 * use to listen on specific actions, movements...
                 */
                listenTo : function(oCharacter) {
                    //@TODO : Add listeners on the current player character
                    //@TODO : Send handled events to the Server Game Process
                    // Keyboard events handler
                    var keyhandler = window,
                        keypressed = {};
                        
                    oCharacter.keypressed = keypressed;

                    // if IE add an invisible layer to handle key events instead of handle it on window
                    if ( Browser.ie )
                    {
                        keyhandler = new Element('input', {'id' : 'keyhandler'});
                        $$('body').grab(keyhandler);
                        stage.addEvent('click', function() { keyhandler.focus(); });
                        stage.fireEvent("click");
                    }

                    // when a key is up
                    keyhandler.addEvent('keyup',
                        function(e)
                        {
                            var key = Object.keyOf(config.key, e.key);
                            // if this key was registered as pressed
                            if ( key != null && typeof keypressed[key] !== 'undefined')
                            {
                                // stop event
                                e.preventDefault().stopPropagation();

                                // unregister key pressed
                                keypressed[key] = null;
                                delete keypressed[key];

                                // if there is timers associated to this key on the current character
                                if ( oCharacter.timers.keyUp[key] )
                                {
                                    // clear the timer
                                    if ( oCharacter.timers.keyUp[key].timer ) {
                                        clearTimeout(oCharacter.timers.keyUp[key].timer);
                                    }
                                    // if a stop function is associated to this timer key
                                    if ( typeof oCharacter.timers.keyUp[key].stop === 'function' ) {
                                        oCharacter.timers.keyUp[key].stop();
                                    }

                                    oCharacter.timers.keyUp[key] = null;
                                    delete oCharacter.timers.keyUp[key];
                                }
                            }
                        }
                    );

                    // handle keydown events
                    keyhandler.addEvent('keydown',
                        function(e)
                        {
                            var key = Object.keyOf(config.key, e.key);
                            // if this is a key we listen
                            if ( key != null )
                            {
                                // stop event
                                e.preventDefault().stopPropagation();
                                // register as pressed key
                                keypressed[key] = true;
                                switch(key)
                                {
                                    case 'up': // special case because you also can go upleft and upright
                                        if ( keypressed['left'] ) { // check if you already go left
                                            oCharacter.process('upleft'); // process upleft
                                        } else if ( keypressed['right'] ) { // check if you already go right
                                            oCharacter.process('upright'); // process upright
                                        } else { // if it's only up
                                            oCharacter.process(key); // process up
                                        }                          
                                        break;
                                    case 'right': // special case because you also can go upright
                                        if ( keypressed['up'] ) { // check if you already go right
                                            oCharacter.process('upright');
                                        } else {
                                            oCharacter.process(key);
                                        }
                                        break;
                                    case 'left': // special case because you also can go upleft
                                        if ( keypressed['up'] ) { // check if you already go left
                                            oCharacter.process('upleft');
                                        } else {
                                            oCharacter.process(key);
                                        }
                                        break;
                                    case 'punch': 
                                        oCharacter.process(key);
                                        break;
                                    case 'kick': 
                                        oCharacter.process(key);
                                        break;
                                    case 'highkick': 
                                        oCharacter.process(key);
                                        break;
                                    case 'fireball': 
                                        oCharacter.process(key);
                                        break;
                                    case 'block': 
                                        oCharacter.process(key);
                                        break;
                                }
                            }
                        }
                    );
                }
            });
            
            
            
            /**
             * DBZ Characters class
             * Respresent a Character on the stage
             */
            var DBZCharacter = new Class({
                Implements : [Options],
                
                ctx : null,
                manager : null,
                buffer : {},
                
                options : {
                    move  : {
                        to : {
                            x : 10,
                            y : 140
                        },
                        from : {
                            x : 0,
                            y : 1,
                            stage : 'left'
                        }
                    },
                    fps : 1000/50,
                    color : 'blue'
                },
                
                // timers which can be cleared with some actions
                timers : {
                    keyUp : {}
                },

                // my sprite position
                image : {
                    x : -1,
                    y : -1
                },

                // differents sizes and positions ( layer, character... )
                sizes : {},
                positions : {},


                // my current direction
                dir : {
                    x : 0,
                    y : 0
                },

                // my current position
                pos : {
                    x : 0,
                    y : 0
                },

                // my power
                power : 1000,

                // my current action
                action : '',
                
                initialize : function(inject, options) {
                    this.manager = inject.manager;
                    this.ctx = this.manager.ctx;
                    
                    this.setOptions(options);
                    
                    this.buffer.canvas = window.document.createElement('canvas');
                    this.buffer.canvas.width = this.options.img.width;
                    this.buffer.canvas.height = this.options.img.height;
                    this.buffer.context = this.buffer.canvas.getContext('2d');
                    var bufferCtx = this.buffer.context;
                  //  window.document.body.appendChild(this.buffer.canvas);
                    var img = this.img =  new Image();
                    this.img.onload = function() {  
                        bufferCtx.drawImage(img, 0, 0);
                    };  
                    this.img.src = this.options.img.src;
                    
                    
                    this.sizes.stage = {
                        x : this.manager.canvas.width,
                        y : this.manager.canvas.height
                    };
                    
                    this.pos = Object.clone(this.options.move.from);
                },
                
                iterate : function() { 
                    this.draw();
                },
                
                draw : function() {
                    
                    // get current image on the sprite coords
                    var pos = this.getSpritePosition();
                    this.image = pos;
                    
                   // this.ctx.save();
                    // draw buffer image at the current image sprite place onto global context
                    this.ctx.drawImage(this.buffer.canvas, this.image.x, this.image.y, config.size.character.x, config.size.character.y, this.pos.x, this.pos.y, config.size.character.x, config.size.character.y);
                   // this.ctx.restore();
                },
                
                getSpritePosition : function() {
                    // waiting is the default action
                    var pos = config.sprites.wait;
                    
                    if ( this.dir.y != 0 ) { // if we are jumping
                        pos = config.sprites.up;
                    } else if ( this.dir.x > 0 ) { // if we are moving to the right of the stage
                        if ( this.pos.stage == 'right' ) { // if we are the left character, we are moving backward
                            pos = config.sprites.backward;
                        } else { // else we are moving forward
                            pos = config.sprites.forward;
                        }
                    } else if ( this.dir.x < 0 ) {// if we are moving to the left of the stage
                        if ( this.pos.stage == 'right' ) {// if we are the right character, we are moving forward
                            pos = config.sprites.forward;
                        } else {// if we are the right character, we are moving backward
                            pos = config.sprites.backward;
                        }
                    } 
                    
                    if ( this.action != '' ) { // if we have a current action performing (kick or block)
                        var sAction = this.action;
                        if ( this.dir.y != 0 && config.sprites[sAction + 'vert']) { // if we are moving up, it's a vertical action
                            sAction = sAction + 'vert';
                        }
                        
                        // if the current action has a sprite, set current position
                        if ( config.sprites[sAction] ) { 
                            pos = config.sprites[sAction];
                        }
                    }
                    
                    // "clone" in order to not modify the config.sprite reference
                    var res = { x : pos.x, y : pos.y };
                    if (this.pos.stage == 'right') {
                        res.x = this.buffer.canvas.width - res.x;
                    }
                    
                    return res;
                },
                
                changePosition : function() {
                    if ( this.pos.stage == 'right') {
                        this.pos.stage = 'left';
                    } else {
                        this.pos.stage = 'right';
                    }
                    
                    // mirror effect on buffer
                    this.buffer.context.translate(this.buffer.canvas.width, 0);
                    this.buffer.context.scale(-1, 1);
                },
                
                process : function() {
                    if ( arguments.length ) {
                        var args = Array.prototype.slice(arguments, 1);
                        if ( !args.length ) {
                            args = [];
                        }
                        if ( DBZCharacter.Tweeners[arguments[0]] ) {
                            DBZCharacter.Tweeners[arguments[0]].apply(this, args);
                        }
                    }
                }
            });
            
            
            DBZCharacter.Tweeners = {
                up : function() {
                    var self = this;
                    if ( !self.dir.y && !self.dir.x && !config.block[self.action])
                    {
                        self.dir.y = 1;
                        setTimeout(function() {
                            self.dir.y = 0;
                        }, config.times.jump);
                        return;
                        self.draw();
                        self.element.set('tween', { duration : config.times.jump/2 });
                        self.element.get('tween').chain(
                            function() 
                            {   // downing
                                self.pos.y = self.options.move.to.y;
                                self.dir.y = -1;
                                self.element.get('tween').chain(
                                    function() 
                                    {   // when coming back to the floor
                                        self.pos.y = self.options.move.to.y;
                                        self.dir.y = 0;
                                        self.action = '';
                                        self.draw();
                                    }
                                ).start('bottom', self.options.move.from.y);

                            }
                        ).start('bottom', self.options.move.to.y);
                    }
                },
                left : function(to) {
                    var self = this;
                    if ( !self.dir.x && !self.dir.y && !config.block[self.action])
                    {
                        self.dir.x = -1;
                        //move
                        var fMove = function()
                        {
                            if ( self.keypressed['left'] )
                            {
                                if ( self.pos.x > 0 ) {
                                    if ( !to ) {
                                        to = self.pos.x - self.options.move.to.x;
                                    }
                                    if ( to < 0 ) {
                                        to = 0;
                                    }

                                    self.pos.x = to;
                                    to = 0;
                                } 
                                // @TODO : tell stage we try to move to left
                                self.timers.keyUp['left'] = {
                                    timer : setTimeout(arguments.callee, self.options.fps),
                                    stop : fStopMove
                                }
                            }
                            else
                            {
                                clearTimeout(self.timers.keyUp['left'].timer);
                                self.timers.keyUp['left'].stop();
                                delete self.timers.keyUp['left'];
                            }
                        };
                        var fStopMove = function()
                        {
                            self.dir.x = 0;
                        }
                        fMove();
                    }
                },

                right : function(to) {
                    var self = this;
                    if ( !self.dir.x && !self.dir.y && !config.block[self.action])
                    {
                        self.dir.x = 1;
                        var fMove = function()
                        {
                            if ( self.keypressed['right'] )
                            {
                                if ( self.pos.x < self.options.move.max.x )
                                {
                                    if ( !to )
                                        to = self.pos.x + self.options.move.to.x;
                                    if ( to > self.options.move.max.x )
                                        to = self.options.move.max.x;

                                    self.pos.x = to;
                                    to = 0;

                                } 
                                // @TODO : tell stage we try to move to right
                                self.timers.keyUp['right'] = {
                                    timer : setTimeout(arguments.callee, self.options.fps),
                                    stop : fStopMove
                                }
                            }
                            else
                            {
                                clearTimeout(self.timers.keyUp['right'].timer);
                                self.timers.keyUp['right'].stop();
                                delete self.timers.keyUp['right'];
                            }
                        };
                        var fStopMove = function()
                        {
                            self.dir.x = 0;
                        }
                        fMove();
                    }

                },
                upleft : function() {
                    this.process('updir', -this.options.move.to.x);
                },
                upright : function() {
                    this.process('updir', +this.options.move.to.x);
                },
                updir : function(to) {
                    var self = this;
                    if ( !self.dir.y && !config.block[self.action])
                    {
                        var sDir = 'right';
                        if ( to < 0 )
                            sDir = 'left';


                        // clear left/right movement 
                        if ( this.timers.keyUp[sDir] )
                        {
                            if ( this.timers.keyUp[sDir].timer )
                                clearTimeout(this.timers.keyUp[sDir].timer);
                            if ( this.timers.keyUp[sDir].stop )
                                this.timers.keyUp[sDir].stop();
                            delete this.timers.keyUp[sDir];
                        }

                        // morph element
                        self.process('up');
                        if ( to > 0 )
                            self.dir.x = 1;
                        else
                            self.dir.x = -1;

                        to = to * 15 + self.pos.x;
                        if ( to < 0 )
                            to = 0;
                        else if ( to > self.options.move.max.x )
                            to = self.options.move.max.x;
                        //move
                        new Fx.Tween(self.layer, {
                            duration : config.times.jump,
                            transition : Fx.Transitions.Sine.easeIn,
                            property : 'left'
                        }).chain(
                            function() 
                            { 
                                self.dir.x = 0; 
                                self.pos.x = to; 
                                self.draw();
                            }
                        ).start(to);
                    }
                },
                punch : function() {
                    if ( this.action == '' )
                    {
                        var self = this;
                        this.action = 'punch';
                        var iTime = config.times.action;
                        if ( this.dir.y != 0 )
                            iTime = config.times.moveaction;
                        self.draw();
                        setTimeout(
                            function()
                            {
                                    self.action = '';
                                    self.draw();
                            }, iTime
                        );
                    }
                },
                kick : function() {
                    if ( this.action == '' )
                    {
                        var self = this;
                        this.action = 'kick';
                        var iTime = config.times.action;
                        if ( this.dir.y != 0 )
                            iTime = config.times.moveaction;
                        self.draw();
                        setTimeout(
                            function()
                            {
                                    self.action = '';
                                    self.draw();
                            }, iTime
                        );
                    }
                },
                highkick : function() {
                    if ( this.action == '' )
                    {
                        var self = this;
                        self.action = 'highkick';
                        var iTime = config.times.action;
                        if ( self.dir.y != 0 )
                            iTime = config.times.moveaction;
                        self.draw();
                        setTimeout(
                            function()
                            {
                                    self.action = '';
                                    self.draw();
                            }, iTime
                        );
                    }
                },
                fireball : function() {
                    if ( this.action == '' )
                    {
                        if ( this.power >= config.power.fireball )
                        {
                            this.power -= config.power.fireball;
                            this.action = 'fireball';

                            // create fireball element
                            var iTime = config.times.fireballaction,
                                sPos = this.pos.stage,
                                iTo = this.sizes.stage.x + config.sprites.fireball.w;

                            var oFireBall = this.getFireBall();

                            // change fireball destination
                            if ( sPos == 'right')
                                iTo *= -1;


                            // tween fireball
                            oFireBall.get('tween')
                                .setOptions(
                                    { 
                                        duration : config.times.fireballmovement, 
                                        transition : 'quad:out' 
                                    }
                                ).chain(function()
                                    {
                                        this.element.destroy();
                                    }
                                ).start('left', this.pos.x + iTo);
                            this.stage.grab(oFireBall);
                        }

                        // draw
                        this.draw();
                        var self=this;
                        setTimeout(
                            function()
                            {
                                self.action = '';
                                self.draw();
                            }, iTime
                        );
                    }
                },
                block : function() {
                    if ( this.action == '' && this.dir.y == 0 && this.dir.x == 0)
                    {
                        var self = this;
                        self.action = 'block';
                        var iTime = config.times.action;
                        self.draw();
                        var checkBlock = function()
                        {
                            if ( !keypressed['block'] )
                            {
                                setTimeout(
                                    function()
                                    {
                                            self.action = '';
                                            self.draw();
                                    }, iTime
                                );
                            }
                            else
                                setTimeout(arguments.callee, config.fps);
                        }
                        checkBlock();
                    }
                }
            };
            
            
            /**
             * Player class
             */
            var Player = new Class({
                Implements : [Options],
                
                id : null,
                
                initialize : function(id, options) {
                    this.id = id;
                    this.setOptions(options);
                }
            });
            
            // initialize game
            var canvas = document.getElementById('dbz'),
                context = canvas.getContext('2d'),
            
                oCurrentPlayer = new Player('dievardump_id', { img : config.images.data.goku }),
                oOtherPlayer = new Player('otherplayer_id', { img : config.images.data.a18 }),
                
                manager = new DrawManager(canvas, context),
                
                inject = {
                    players : [oCurrentPlayer, oOtherPlayer],
                    currentPlayer : oCurrentPlayer,
                    drawer : manager,
                    stage : canvas
                },
                options = {
                    
                };
            
            var oGame = new DBZ(inject, options);
            
            console.log(oGame);
                    
        });
    </script>
    <link type="text/css" rel="stylesheet" media="screen" href="http://yui.yahooapis.com/2.9.0/build/reset/reset-min.css" />
    <link type="text/css" rel="stylesheet" media="screen" href="./assets/css/main.css" />
</head>
<body>
    <div id="stage">
        <canvas id="dbz" height="380" width="600">
            Your browser does not support canvas element.<br/>
            Try to use latest version of Firefox, Chrome, Safari, Opera or Internet Explorer (9+) to correctly display this page.<br/>
            Sorry for the inconvenience caused.<br/><br/>
            DieVarDump.
        </canvas>
    </div>
    
    <div class="sample character-container">
        <div class="shadow">&nbsp;</div>
    </div>
    <img id="a18" class="sprite" src="./assets/img/sprites/characters/a18.png" width="203" height="204"/>
    <img id="goku" class="sprite" src="./assets/img/sprites/characters/goku.png" width="203" height="204"/>
    <input type="text" value="" name="keyhandler" id="keyhandler" />
</body>
</html>